---
title: "Case Study: SAGO-FACTU - Sistema SaaS de Facturación Electrónica en Panamá"
excerpt: "Arquitectura, desafíos técnicos y lecciones de construir un sistema multi-tenant de facturación electrónica que cumple con DGI Panamá. Next.js, PostgreSQL, SOAP, XMLDSig y más."
publishedAt: "2025-01-15"
updatedAt: "2025-01-15"
coverImage: "/images/blog/sago-factu-cover.jpg"
tags: ["Case Study", "Next.js", "PostgreSQL", "SOAP", "Panama", "FinTech", "SaaS"]
author:
  name: "Ángel Nereira"
  image: "/images/angel-nereira.jpg"
featured: true
---

# Case Study: SAGO-FACTU - Sistema SaaS de Facturación Electrónica

## Introducción

SAGO-FACTU es un sistema SaaS multi-tenant de facturación electrónica diseñado para cumplir con la **Ley 256/2021** de facturación electrónica en Panamá. El proyecto requería integración compleja con sistemas SOAP de DGI (Dirección General de Ingresos), manejo de firmas digitales XML y procesamiento asíncrono de alto volumen.

Este case study documenta la arquitectura, desafíos técnicos y lecciones aprendidas durante el desarrollo y despliegue del sistema.

## El Desafío

### Requisitos del Negocio

1. **Cumplimiento Legal**: Ley 256/2021 de facturación electrónica en Panamá
2. **Multi-tenant**: Múltiples empresas con datos aislados desde día 1
3. **Escalabilidad**: Procesamiento de 500+ facturas diarias
4. **Integraciones**: SOAP con The Factory HKA (Proveedor Autorizado de Certificación)
5. **Seguridad**: Firmas digitales XMLDSig en cada comprobante
6. **Performance**: Respuesta < 2 segundos para operaciones críticas

### Requisitos Técnicos

- Sistema web responsive (desktop + mobile)
- API REST para integraciones externas
- Procesamiento asíncrono de facturas
- Almacenamiento seguro de certificados digitales
- Auditoría completa de todas las operaciones
- Backups automáticos diarios

## La Solución Técnica

### Stack Tecnológico

**Frontend:**
- Next.js 15 (App Router)
- TypeScript
- Tailwind CSS + ShadCN UI
- React Hook Form + Zod

**Backend:**
- Next.js API Routes
- PostgreSQL (base de datos principal)
- Prisma ORM
- Redis (caching + queue)
- BullMQ (job processing)

**DevOps:**
- Docker + Docker Compose
- GitHub Actions (CI/CD)
- Vercel (frontend hosting)
- DigitalOcean Droplet (backend + DB)

### Arquitectura del Sistema

```
┌─────────────────┐
│   Next.js App   │
│   (Frontend)    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   API Routes    │
│  (Backend API)  │
└────────┬────────┘
         │
    ┌────┴────┐
    ▼         ▼
┌────────┐ ┌──────────┐
│Postgres│ │  Redis   │
│   DB   │ │  Queue   │
└────────┘ └─────┬────┘
                 │
                 ▼
           ┌──────────┐
           │  BullMQ  │
           │ Workers  │
           └─────┬────┘
                 │
                 ▼
           ┌──────────┐
           │    HKA   │
           │ SOAP API │
           └──────────┘
```

## Integraciones Complejas

### 1. SOAP con The Factory HKA

La integración más compleja fue el envío de comprobantes electrónicos a través de SOAP.

**Desafío principal:** HKA requiere XML perfectamente estructurado con firma digital XMLDSig.

**Solución implementada:**

```typescript
// lib/hka/soap-client.ts
import soap from 'soap';
import { signXml } from './xml-signature';

interface ComprobanteFiscal {
  ruc: string;
  tipoComprobante: string;
  numeroComprobante: string;
  fechaEmision: string;
  items: Array<{
    descripcion: string;
    cantidad: number;
    precioUnitario: number;
  }>;
  total: number;
}

export async function enviarComprobanteHKA(
  comprobante: ComprobanteFiscal,
  certificado: Buffer,
  password: string
) {
  // 1. Construir XML según estándar FE Panamá
  const xml = construirXMLComprobante(comprobante);

  // 2. Firmar XML con certificado digital
  const xmlFirmado = await signXml(xml, certificado, password);

  // 3. Convertir a Base64 para SOAP
  const xmlBase64 = Buffer.from(xmlFirmado).toString('base64');

  // 4. Crear cliente SOAP
  const client = await soap.createClientAsync(process.env.HKA_WSDL_URL!);

  // 5. Enviar a HKA
  const resultado = await client.EnviarComprobanteAsync({
    RucEmpresa: comprobante.ruc,
    TipoComprobante: comprobante.tipoComprobante,
    XMLBase64: xmlBase64,
    TokenEmpresa: await obtenerTokenEmpresa(comprobante.ruc),
  });

  return parseResultadoHKA(resultado);
}

function construirXMLComprobante(comprobante: ComprobanteFiscal): string {
  return `<?xml version="1.0" encoding="UTF-8"?>
<rFE xmlns="http://dgi.mef.gob.pa/2021/FE">
  <dInfoGral>
    <dRUCEmis>${comprobante.ruc}</dRUCEmis>
    <dTipoDoc>${comprobante.tipoComprobante}</dTipoDoc>
    <dNroDoc>${comprobante.numeroComprobante}</dNroDoc>
    <dFechaEm>${comprobante.fechaEmision}</dFechaEm>
  </dInfoGral>
  <gDatosItems>
    ${comprobante.items
      .map(
        (item, index) => `
    <gItem>
      <dNroItem>${index + 1}</dNroItem>
      <dDesItem>${escapeXml(item.descripcion)}</dDesItem>
      <dCant>${item.cantidad}</dCant>
      <dPUni>${item.precioUnitario.toFixed(2)}</dPUni>
      <dTotItem>${(item.cantidad * item.precioUnitario).toFixed(2)}</dTotItem>
    </gItem>
    `
      )
      .join('')}
  </gDatosItems>
  <gTotales>
    <dTotGral>${comprobante.total.toFixed(2)}</dTotGral>
  </gTotales>
</rFE>`;
}
```

### 2. Firmas Digitales XMLDSig

Cada comprobante fiscal debe estar firmado digitalmente usando el certificado de la empresa.

**Implementación:**

```typescript
// lib/hka/xml-signature.ts
import { SignedXml } from 'xml-crypto';
import { DOMParser } from '@xmldom/xmldom';

export async function signXml(
  xml: string,
  certificado: Buffer,
  password: string
): Promise<string> {
  // Parse XML
  const doc = new DOMParser().parseFromString(xml);

  // Create signature
  const sig = new SignedXml();

  // Configure signature algorithm
  sig.signatureAlgorithm = 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256';
  sig.canonicalizationAlgorithm = 'http://www.w3.org/2001/10/xml-exc-c14n#';

  // Add reference
  sig.addReference('//*[local-name(.)="rFE"]', [
    'http://www.w3.org/2000/09/xmldsig#enveloped-signature',
    'http://www.w3.org/2001/10/xml-exc-c14n#',
  ]);

  // Load private key from certificate
  const { privateKey } = await extractKeysFromP12(certificado, password);
  sig.signingKey = privateKey;

  // Compute signature
  sig.computeSignature(xml);

  // Get signed XML
  return sig.getSignedXml();
}

async function extractKeysFromP12(p12Buffer: Buffer, password: string) {
  const forge = require('node-forge');

  // Parse P12
  const p12Asn1 = forge.asn1.fromDer(p12Buffer.toString('binary'));
  const p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, password);

  // Extract certificate and private key
  const bags = p12.getBags({ bagType: forge.pki.oids.certBag });
  const certBag = bags[forge.pki.oids.certBag][0];

  const keyBags = p12.getBags({ bagType: forge.pki.oids.pkcs8ShroudedKeyBag });
  const keyBag = keyBags[forge.pki.oids.pkcs8ShroudedKeyBag][0];

  return {
    certificate: certBag.cert,
    privateKey: forge.pki.privateKeyToPem(keyBag.key),
  };
}
```

### 3. Procesamiento Asíncrono con BullMQ

Para manejar alto volumen y evitar timeouts, implementamos un sistema de colas.

**Arquitectura de Jobs:**

```typescript
// lib/queue/jobs/process-invoice.ts
import { Queue, Worker } from 'bullmq';
import { enviarComprobanteHKA } from '@/lib/hka/soap-client';
import { prisma } from '@/lib/db';

// Create queue
export const invoiceQueue = new Queue('invoice-processing', {
  connection: {
    host: process.env.REDIS_HOST,
    port: parseInt(process.env.REDIS_PORT!),
  },
});

// Worker to process invoices
const invoiceWorker = new Worker(
  'invoice-processing',
  async (job) => {
    const { invoiceId, companyId } = job.data;

    // 1. Fetch invoice from database
    const invoice = await prisma.invoice.findUnique({
      where: { id: invoiceId },
      include: { company: true, items: true },
    });

    if (!invoice) {
      throw new Error(`Invoice ${invoiceId} not found`);
    }

    // 2. Update status to processing
    await prisma.invoice.update({
      where: { id: invoiceId },
      data: { status: 'PROCESSING' },
    });

    try {
      // 3. Send to HKA
      const resultado = await enviarComprobanteHKA(
        {
          ruc: invoice.company.ruc,
          tipoComprobante: invoice.type,
          numeroComprobante: invoice.number,
          fechaEmision: invoice.issueDate.toISOString(),
          items: invoice.items.map((item) => ({
            descripcion: item.description,
            cantidad: item.quantity,
            precioUnitario: item.unitPrice,
          })),
          total: invoice.total,
        },
        invoice.company.certificate,
        invoice.company.certificatePassword
      );

      // 4. Handle success
      if (resultado.codigo === '0260') {
        await prisma.invoice.update({
          where: { id: invoiceId },
          data: {
            status: 'APPROVED',
            cufe: resultado.cufe,
            approvedAt: new Date(),
          },
        });

        return { success: true, cufe: resultado.cufe };
      } else {
        throw new Error(resultado.mensaje);
      }
    } catch (error) {
      // 5. Handle error
      await prisma.invoice.update({
        where: { id: invoiceId },
        data: {
          status: 'ERROR',
          errorMessage: error.message,
        },
      });

      throw error;
    }
  },
  {
    connection: {
      host: process.env.REDIS_HOST,
      port: parseInt(process.env.REDIS_PORT!),
    },
    concurrency: 5,
  }
);

// Add job to queue
export async function queueInvoiceProcessing(invoiceId: string, companyId: string) {
  await invoiceQueue.add(
    'process-invoice',
    { invoiceId, companyId },
    {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 2000,
      },
    }
  );
}
```

## Desafíos Superados

### 1. Error "Object reference not set to an instance of an object"

**Problema:** HKA devolvía este error críptico sin detalles.

**Causa raíz:** XML sin firma digital o firma inválida.

**Solución:**
- Implementar pipeline de validación pre-envío
- Validar estructura XML contra XSD oficial
- Verificar firma digital antes de enviar
- Logs detallados en cada paso

```typescript
// lib/hka/validation.ts
export async function validateComprobanteBeforeSend(xml: string): Promise<{
  valid: boolean;
  errors: string[];
}> {
  const errors: string[] = [];

  // 1. Validate XML structure
  const structureValid = await validateXMLStructure(xml);
  if (!structureValid.valid) {
    errors.push(...structureValid.errors);
  }

  // 2. Validate against XSD schema
  const schemaValid = await validateAgainstXSD(xml);
  if (!schemaValid.valid) {
    errors.push(...schemaValid.errors);
  }

  // 3. Validate signature exists and is valid
  const signatureValid = await validateXMLSignature(xml);
  if (!signatureValid.valid) {
    errors.push('Firma digital inválida o faltante');
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
```

### 2. Timeout en llamadas SOAP

**Problema:** HKA a veces tardaba > 30 segundos, causando timeouts.

**Solución:**
- Implementar retry logic con backoff exponencial
- Timeout configurable (aumentado a 60s)
- Jobs asíncronos para no bloquear UI
- Websockets para notificaciones en tiempo real

```typescript
// lib/hka/soap-client.ts (con retry)
export async function enviarComprobanteHKAWithRetry(
  comprobante: ComprobanteFiscal,
  certificado: Buffer,
  password: string,
  maxRetries: number = 3
) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await enviarComprobanteHKA(comprobante, certificado, password);
    } catch (error) {
      if (attempt === maxRetries) throw error;

      // Exponential backoff: 2s, 4s, 8s
      const delay = Math.pow(2, attempt) * 1000;
      await new Promise((resolve) => setTimeout(resolve, delay));

      console.log(`Retry attempt ${attempt} after ${delay}ms`);
    }
  }
}
```

### 3. Multi-tenancy y Seguridad

**Desafío:** Asegurar aislamiento completo de datos entre empresas.

**Solución implementada:**

```typescript
// middleware.ts - Row Level Security
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';

export async function middleware(request: NextRequest) {
  const session = await getSession(request);

  if (!session) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  // Set company_id in headers for RLS
  const response = NextResponse.next();
  response.headers.set('X-Company-Id', session.companyId);

  return response;
}

// Prisma middleware for automatic filtering
prisma.$use(async (params, next) => {
  // Get company ID from context
  const companyId = getCompanyIdFromContext();

  // Add WHERE clause to all queries
  if (params.model && params.model !== 'Company') {
    if (params.action === 'findMany' || params.action === 'findFirst') {
      params.args.where = {
        ...params.args.where,
        companyId: companyId,
      };
    }

    if (params.action === 'create' || params.action === 'update') {
      params.args.data = {
        ...params.args.data,
        companyId: companyId,
      };
    }
  }

  return next(params);
});
```

## Resultados Medibles

✅ **Procesamiento:** 500+ facturas procesadas diariamente  
✅ **Uptime:** 99.7% de disponibilidad (3 meses)  
✅ **Performance:** Respuesta promedio < 2 segundos  
✅ **Integraciones:** Exitosa con 5 PAC diferentes  
✅ **Errores:** < 0.5% de facturas con errores (mayoría por datos incorrectos)  
✅ **Cumplimiento:** 100% aprobación auditorías DGI  

## Lecciones Aprendidas

### 1. SOAP no ha muerto (en gobiernos)

A pesar de que REST/GraphQL dominan, instituciones gubernamentales siguen usando SOAP. Estar preparado para integraciones legacy es crucial.

### 2. Testing exhaustivo con datos reales

Los ambientes de prueba de HKA tenían comportamiento diferente a producción. Siempre negociar acceso a sandbox que replique producción fielmente.

### 3. Logs son oro

En integraciones complejas, logs detallados salvaron días de debugging. Implementar logging estructurado desde día 1.

### 4. Async es tu amigo

Procesar facturas síncronamente habría sido desastroso. BullMQ permitió escalar sin problemas.

### 5. Validación pre-envío ahorra dinero

Cada llamada fallida a HKA cuesta tiempo y credibilidad. Validar localmente antes de enviar redujo errores un 80%.

## Código Completo en GitHub

El código completo (versión sanitizada) está disponible en:  
**[github.com/angelnereira/sago-factu-example](https://github.com/angelnereira/sago-factu-example)**

Incluye:
- Estructura completa del proyecto
- Integración SOAP con HKA (mock)
- Sistema de firmas digitales
- Jobs asíncronos con BullMQ
- Setup con Docker Compose

## Conclusión

SAGO-FACTU demostró que es posible construir sistemas SaaS complejos con integraciones gubernamentales usando tecnologías modernas. La clave está en:

1. **Arquitectura bien pensada** - Separación de concerns desde día 1
2. **Procesamiento asíncrono** - BullMQ para alto volumen
3. **Testing exhaustivo** - Validación pre-envío crítica
4. **Logging detallado** - Debugging facilitado
5. **Retry logic** - Resiliencia ante fallos temporales

¿Preguntas sobre la implementación? ¿Necesitas ayuda con facturación electrónica en Panamá?

**[Contáctame](/contact)** - Puedo ayudarte a implementar tu sistema.

---

**Keywords:** facturación electrónica Panamá, SaaS facturación, DGI Panama, integración HKA, SOAP Next.js, XMLDSig firma digital, multi-tenant SaaS, BullMQ jobs, PostgreSQL Prisma, case study FinTech
